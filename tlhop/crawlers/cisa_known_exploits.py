#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import requests
import shutil
from bs4 import BeautifulSoup
import os
import glob
from datetime import datetime
import urllib.request
import pandas as pd

class CISAKnownExploits(object):

    """
    CISA's Known Exploited Vulnerabilities Catalog

    CISA maintains a catalog of vulnerabilities that have been exploited in the wild.
    
    Reference: https://www.cisa.gov/known-exploited-vulnerabilities
    """

    _ERROR_MESSAGE_000 = "[ERROR] This crawler requires an environment variable 'TLHOP_DATASETS_PATH' containing a folder path to be used as storage to all TLHOP datasets."
    _ERROR_MESSAGE_001 = ("[ERROR] Destination output already exists ('{}') but RELEASE file is " +
        "missing. Desconsidering previous files, if they exists.")
    _ERROR_MESSAGE_002 = "[ERROR] Mentioned file '{}' in RELEASE was not found."
    
    _INFO_MESSAGE_001 = "Last crawling timestamp: {}"
    _INFO_MESSAGE_002 = "A most recent version of the current dataset was found."
    _INFO_MESSAGE_003 = "The current dataset version is the most recent."
    _INFO_MESSAGE_004 = "New dataset version is download with success!"
    _INFO_MESSAGE_005 = "Downloading new file ..."
    
    def __init__(self):
        """
        During the initialization process, it will check if a TLHOP directory folder is set and valid.
        It also will check on the Internet if an new dataset version is available to download in case 
        of a previous download was found during folder lookup.
        """
        self.download_url = "https://www.cisa.gov/sites/default/files/csv/known_exploited_vulnerabilities.csv"
        self.path = "cisa-known-exploits/"
        self.expected_schema = {"outname": "known_exploited_vulnerabilities.csv"}
        self.new_version = None
        self.last_file = {}
    
        root_path = os.environ.get("TLHOP_DATASETS_PATH", None)
        if not root_path:
            raise Exception(self._ERROR_MESSAGE_000)
        self.root_path = (root_path+"/").replace("//", "/")
        self.basepath = self.root_path+self.path
        
        self._check_status()
        self._check_for_new_files(self.download_url)

    def _check_status(self):
        if not os.path.exists(self.basepath):
            os.mkdir(self.basepath)
        elif os.path.exists(self.basepath+"RELEASE"):
            with open(self.basepath+"RELEASE", "r") as f:
                etag, timestamp, filename = f.read().split("\n")[0].split("|")
                if not os.path.exists(self.basepath+filename):
                    raise Exception(self._ERROR_MESSAGE_001.format(filename))
                else:
                    self.last_file = {"etag": etag, "timestamp": timestamp, "outname": filename}
                    print(self._INFO_MESSAGE_001.format(timestamp))
        else:
            print(self._ERROR_MESSAGE_001.format(self.basepath))
        
    def _check_for_new_files(self, download_url):

        info = urllib.request.urlopen(download_url)
        self.new_version = info.info()["etag"]
            
        
        if self.new_version != self.last_file.get("url", None):
            print(self._INFO_MESSAGE_002)
        else:
            print(self._INFO_MESSAGE_003)

    def describe(self):
        """
        Function to describe some informations about the dataset: 
        description, reference and fields.
        """
        print("""
        # CISA's Known Exploited Vulnerabilities Catalog
        
        - Description: CISA maintains a catalog of vulnerabilities that have been exploited in the wild.
        - Reference: https://www.cisa.gov/known-exploited-vulnerabilities
        - Download link: {}
        """.format(self.download_url))

    def download(self):
        """
        Downloads a new dataset version available in its source link. 
        """

        print(self._INFO_MESSAGE_005)
        
        pd.read_csv(self.download_url).to_csv(self.basepath+self.expected_schema["outname"] , sep=";", index=False)
        
        now = datetime.now().strftime("%Y%m%d_%H%M%S")
        msg = "{}|{}|{}".format(self.new_version, now, self.expected_schema["outname"])
        f = open(self.basepath+"RELEASE", "w")
        f.write(msg)
        f.close()
        print(self._INFO_MESSAGE_004)
        return True
